type BigIntStr = bigint | string;
type Decimal = `${number}` | number | bigint;
/**
 * ISO 8601 format,
 * new Date().toISOString()
 *
 * @example
 * - '2020-03-03T02:12:53.123Z'
 */
type DateISOString = `${N4}-${N2}-${N2}T${N2}:${N2}:${N2}.${N3}Z`;
/**
 * ISO 8601 format with timezone offset
 *
 * @example
 * - '2020-03-03T02:12:53.123Z'
 * - '2021-03-03T10:12:53.123+08:00'
 */
type ISO8601String = DateISOString | `${N4}-${N2}-${N2}T${N2}:${N2}:${N2}.${N3}+${N2}:${N2}` | `${N4}-${N2}-${N2}T${N2}:${N2}:${N2}.${N3}-${N2}:${N2}`;
type N4 = `${number}${number}${number}${number}`;
type N3 = `${number}${number}${number}`;
type N2 = `${number}${number}`;

type ToTuple<T> = T extends any[] ? T : any[];
/**
 * Union tow types, with optional excluded keys
 * @example `Spread<T, K, 'foo'>` or `Spread<T, K, 'foo' | 'bar'>`
 * @see https://github.com/microsoft/TypeScript/pull/13288#issuecomment-412230721
 */
type Spread<T1, T2, KeyExcludeOptinal = void> = {
    [K in Exclude<keyof T1, KeyExcludeOptinal | keyof T2>]: T1[K];
} & {
    [K in Exclude<keyof T2, KeyExcludeOptinal>]: T2[K];
};
/**
 * @example `type R = AllValues<Record<'uid', 'tbUserUid'>>`
 * @see https://stackoverflow.com/a/56416192
 */
type AllValues<T extends Record<PropertyKey, PropertyKey>> = {
    [P in keyof T]: {
        key: P;
        value: T[P];
    };
}[keyof T];
/**
 * @example `type R = KeyFromValue<{uid: 'tbUserUid'}, 'tbUserUid'>` got `uid`
 * @ref https://stackoverflow.com/a/57726844
 */
type KeyFromValue<T, V> = {
    [key in keyof T]: V extends T[key] ? key : never;
}[KnownKeys<T> & keyof T];
/**
 * Invert key/value of type/interface
 * @example `type R = Invert<{x: 'a', y: 'b'}>` got `{a: 'x', b: 'y'}`
 * @example `type R = Invert<{x: 'a', y: 'b', z: 'a'}>` got `{a: 'x' | 'z', b: 'y'}`
 * @see https://stackoverflow.com/a/57726844
 */
type Invert<T extends Record<string, string>> = {
    [K in T[KnownKeys<T> & (keyof T)]]: KeyFromValue<T, K>;
};
/**
 * @see https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
 */
type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;
/**
 * (Experimental) Equals two types which convert by FormatIntersect<>
 * ```
 */
type EqualsExt<X, Y> = Equals<FormatIntersect<X>, FormatIntersect<Y>>;
type OverwriteNeverToUnknown<T> = {
    [fld in keyof T]: T[fld] extends never ? unknown : T[fld];
};
/**
 * (Experimental) Rewrite members of intersect type into one type deeply
 *
 * @example ```ts
 * {foo: number} & {bar: string} => {foo: number, bar: string}
 * ```
 */
type FormatIntersect<T, deep extends boolean = true> = T extends Record<string | number, any> ? T extends any[] | Function | Date ? T : {
    [K in keyof T]: deep extends true ? FormatIntersect<T[K], true> : T[K];
} : T;
/**
 * Retrieve keys
 * @see https://stackoverflow.com/a/51955852/2887218
 */
type KnownKeys<T> = {
    [K in keyof T]: string extends K ? never : number extends K ? never : symbol extends K ? never : K;
} extends {
    [_ in keyof T]: infer U;
} ? U : never;
/**
 * Retrive types
 * @see https://stackoverflow.com/a/51955852/2887218
 */
type ValuesOf<T> = T extends {
    [_ in keyof T]: infer U;
} ? U : never;
type IfAny<T, Y, N> = 0 extends (1 & T) ? Y : N;
/**
 * @link https://stackoverflow.com/a/55541672
 */
type OverwriteAnyToUnknown<T> = IfAny<T, unknown, T>;
/**
 * Restrict using either exclusively the keys of T or exclusively the keys of U.
 *
 * No unique keys of T can be used simultaneously with any unique keys of U.
 *
 * Example:
 * `const myVar: XOR<T, U>`
 *
 * More: https://github.com/maninak/ts-xor
 */
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
/**
* Get the keys of T without any keys of U.
*/
type Without<T, U> = {
    [P in Exclude<keyof T, keyof U>]?: never;
};

/** Value of key-value pairs object */
type PlainJsonValue = boolean | number | string | null;
/**
 * Typeof JSON object parsed from Response data
 * simple key-value pairs object.
 */
interface JsonObject {
    [key: string]: PlainJsonValue | PlainJsonValue[] | JsonObject | JsonObject[];
}
type JsonType = PlainJsonValue | JsonType[] | {
    [property: string]: JsonType;
};
interface LiteralObject {
    [property: string]: string | LiteralObject;
}
/** Custom response json data structure */
type JsonResp<T = never> = {
    /** 0: success */
    code: number;
    /**
     * keyof typeof ErrorCode, eg. 'E_Not_Found'
     */
    codeKey?: string;
    msg?: string | null;
    /** Request id */
    reqId?: string;
} & ([T] extends [never] ? {
    data?: unknown;
} : {
    data: T;
});

declare const dummyForCI = true;

interface Func {
    (...args: any[]): any | Promise<any>;
    (this: any, ...args: any[]): any | Promise<any>;
}

type StrSplit<S extends string, D extends string> = string extends S ? string[] : S extends `${infer T}${D}${infer U}` ? [T, ...StrSplit<U, D>] : [
    S
];
type V = string | number | boolean | bigint;
type TupleJoin<T extends V[], D extends string> = T extends [] ? '' : T extends [unknown] ? `${T[0]}` : T extends [unknown, ...infer U] ? `${T[0]}${D}${TupleJoin<U, D>}` : string;
type CamelToSnake<T extends string, D extends string = '_'> = string extends D ? never : T extends `${infer F extends D}${infer R}` ? `${F}${_CamelToSnake<R, D>}` : _CamelToSnake<T, D> extends `${D}${infer U}` ? U : _CamelToSnake<T, D>;
type _CamelToSnake<T extends string, D extends string> = T extends `${infer U}${infer Rest}` ? U extends D ? `${U}${_CamelToSnake<Rest, D>}` : Uppercase<U> extends U ? `${D}${Lowercase<U>}${_CamelToSnake<Rest, D>}` : `${U}${_CamelToSnake<Rest, D>}` : Lowercase<T>;
type SnakeToCamel<T extends string, D extends string = '_', TrimStart extends boolean = false, TrimEnd extends boolean = false> = string extends D ? never : T extends `${infer F extends D}${infer R}` ? TrimStart extends true ? `${SnakeToCamel<R, D, true, TrimEnd>}` : `${F}${SnakeToCamel<R, D, false, TrimEnd>}` : TrimEnd extends true ? _SnakeToCamelWoTailing<T, D> : _SnakeToCamelWithTailing<T, D>;
type _SnakeToCamelWoTailing<T extends string, D extends string> = T extends `${infer U}${infer R}` ? U extends D ? `${_SnakeToCamelWoTailing<Capitalize<R>, D>}` : `${U}${_SnakeToCamelWoTailing<R, D>}` : T;
type _SnakeToCamelWithTailing<T extends string, D extends string> = T extends `${infer U}${infer R}` ? R extends '' ? U : U extends D ? `${_SnakeToCamelWithTailing<Capitalize<R>, D>}` extends `${infer U1 extends D}${infer R1}` ? `${U}${U1}${_SnakeToCamelWithTailing<Capitalize<R1>, D>}` : `${_SnakeToCamelWithTailing<Capitalize<R>, D>}` : `${U}${_SnakeToCamelWithTailing<R, D>}` : T;
type SnakeToPascal<T extends string, D extends string = '_', TrimStart extends boolean = false, TrimEnd extends boolean = false> = string extends D ? never : T extends `${infer F extends D}${infer R}` ? TrimStart extends true ? `${Capitalize<SnakeToPascal<R, D, true, TrimEnd>>}` : `${F}${Capitalize<SnakeToPascal<R, D, false, TrimEnd>>}` : TrimEnd extends true ? _SnakeToCamelWoTailing<Capitalize<T>, D> : _SnakeToCamelWithTailing<Capitalize<T>, D>;
type CamelKeys<T, D extends string = '_', Recursive extends boolean = false> = T extends object ? _CamelKeys<T, D, Recursive> : never;
type _CamelKeys<T, D extends string = '_', Recursive extends boolean = false> = Recursive extends true ? RecursiveCamelKeys<T, D> : RecordCamelKeys<T, D>;
type RecursiveCamelKeys<T, D extends string = '_'> = {
    [K in keyof T as `${SnakeToCamel<K & string, D>}`]: T[K] extends Record<string, unknown> ? RecursiveCamelKeys<T[K], D> : T[K];
};
type RecordCamelKeys<T, D extends string = '_'> = {
    [K in keyof T as `${SnakeToCamel<K & string, D>}`]: T[K];
};
type PascalKeys<T, D extends string = '_', Recursive extends boolean = false> = T extends object ? _PascalKeys<T, D, Recursive> : never;
type _PascalKeys<T, D extends string = '_', Recursive extends boolean = false> = Recursive extends true ? RecursivePascalKeys<T, D> : RecordPascalKeys<T, D>;
type RecursivePascalKeys<T, D extends string = '_'> = {
    [K in keyof T as `${SnakeToPascal<K & string, D>}`]: T[K] extends Record<string, unknown> ? RecursivePascalKeys<T[K], D> : T[K];
};
type RecordPascalKeys<T, D extends string = '_'> = {
    [K in keyof T as `${SnakeToPascal<K & string, D>}`]: T[K];
};
type SnakeKeys<T, D extends string = '_', Recursive extends boolean = false> = T extends object ? _SnakeKeys<T, D, Recursive> : never;
type _SnakeKeys<T, D extends string = '_', Recursive extends boolean = false> = Recursive extends true ? RecursiveSnakeKeys<T, D> : RecordSnakeKeys<T, D>;
type RecursiveSnakeKeys<T, D extends string = '_'> = {
    [K in keyof T as `${CamelToSnake<K & string, D>}`]: T[K] extends Record<string, unknown> ? RecursiveSnakeKeys<T[K], D> : T[K];
};
type RecordSnakeKeys<T, D extends string = '_'> = {
    [K in keyof T as `${CamelToSnake<K & string, D>}`]: T[K];
};

declare enum CaseType {
    camel = "camel",
    pascal = "pascal",
    snake = "snake",
    none = "none"
}
type JoinTableWithCaseConvert<T1 extends {}, T2 extends {}, Prefix extends string, CaseConvert extends CaseType> = CaseConvertTable<JoinTable<T1, T2, Prefix>, CaseConvert>;
type CaseConvertTable<T extends {}, CaseConvert extends CaseType> = CaseConvert extends CaseType.camel ? RecordCamelKeys<T> : CaseConvert extends CaseType.snake ? RecordSnakeKeys<T> : CaseConvert extends CaseType.pascal ? RecordPascalKeys<T> : T;
type JoinTable<T1 extends {}, T2 extends {}, Prefix extends string> = T1 & _JoinCover<T1, T2, Prefix> & _JoinDiff<T1, T2>;
type _JoinCover<T1 extends object, T2 extends object, Prefix extends string> = {
    [K in keyof Pick<T2, keyof (T1 | T2)> as `${Prefix}_${K & string}`]: T2[K];
};
type _JoinDiff<T1 extends object, T2 extends object> = {
    [K in keyof Omit<T2, keyof (T1 | T2)>]: T2[K];
};
/**
 * Create scoped column name from all tables of D,
 * filter by Tb name like 'tb_user' | 'tb_order'
 */
type DbScopedColsByKey<D extends {}, Tb extends keyof D = keyof D> = D extends Record<infer F extends (Tb extends string ? Tb : string), unknown> ? F extends unknown ? `${F}.${StrKey<D[F]>}` : never : never;
/**
 * Create scoped column name from all tables of D,
 * filter by Tb Type
 */
type DbScopedColsByTableType<D extends {}, T = undefined> = T extends undefined ? DbScopedColsByKey<D> : D extends Record<infer F extends string, unknown> ? F extends unknown ? T extends D[F] ? `${F}.${(keyof D[F]) & string}` : never : never : never;
type UnwrapArrayMember<T> = T extends (infer M)[] ? M : T;
type StrKey<T> = keyof T & string;
/**
 * Splite `tb_user_bar.foo_id` to `tb_user_bar` and `foo_id`
 */
type SplitScopedColumn<D, SCol> = SCol extends `${infer Tb extends StrKey<D>}.${infer Col}` ? [Tb, Col] : never;

/**
 * For npm package.json
 *
 * @link https://docs.npmjs.com/files/package.json
 */
interface NpmPkg {
    name: string;
    version?: string;
    description?: string;
    bin?: NpmPkgStringObj;
    browser?: string;
    bugs?: NpmPkgStringObj;
    bundledDependencies?: string[];
    config?: NpmPkgStringObj;
    contributors?: NpmPkgPersion[];
    cpu?: string[];
    dependencies?: NpmPkgStringObj;
    devDependencies?: NpmPkgStringObj;
    engines?: NpmPkgStringObj;
    es2015?: string;
    keywords?: string[];
    homepage?: string;
    license?: string;
    main?: string | string[];
    man?: string | string[];
    module?: string;
    optionalDependencies?: NpmPkgStringObj;
    os?: string[];
    peerDependencies?: NpmPkgStringObj;
    /** @deprecated */
    preferGlobal?: boolean;
    private?: boolean;
    publishConfig?: NpmPkgPublishConfig;
    repository: NpmPkgRepository | string;
    scripts?: NpmPkgStringObj;
    types?: string;
    [key: string]: any;
}
interface NpmPkgPublishConfig {
    access: boolean;
    registry: string;
    tag: string;
    [key: string]: string | boolean;
}
interface NpmPkgRepository {
    type: 'git' | 'svn' | 'hg';
    url: string;
    directory?: string;
}
interface NpmPkgPersion {
    name: string;
    url?: string;
    email?: string;
}
interface NpmPkgStringObj {
    [name: string]: string;
}

/**
 * Note: order of result is not exact
 * @example ```
 *  type LongerUnion = { name: 'shanon' } | 1 | 2 | 3
 *  type TestType = UnionToTuple<LongerUnion> // [3, 2, {name: 'shanon'}, 1]
 * ```
 * @see https://stackoverflow.com/a/55858763
 */
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;

/**
 * `/proc/(cpuinfo | meminfo | stat)`
 */
interface ProcInfo {
    cpuinfo: ProcCpuinfo;
    meminfo: ProcMeminfo;
    diskstats: ProcDiskstats;
    stat: ProcStat;
}
interface ProcCpuinfo {
    [key: string]: string;
    processor: string;
    vendor_id: string;
    'cpu family': string;
    model: string;
    'model name': string;
    stepping: string;
    microcode: string;
    'cpu MHz': string;
    'cache size': string;
    'physical id': string;
    siblings: string;
    'core id': string;
    'cpu cores': string;
    apicid: string;
    'initial apicid': string;
    fpu: string;
    fpu_exception: string;
    'cpuid level': string;
    wp: string;
    flags: string;
    bugs: string;
    bogomips: string;
    'clflush size': string;
    cache_alignment: string;
    'address sizes': string;
}
interface ProcMeminfo {
    [key: string]: string;
    MemTotal: string;
    MemFree: string;
    MemAvailable: string;
    Buffers: string;
    Cached: string;
    SwapCached: string;
    Active: string;
    Inactive: string;
    'Active(anon)': string;
    'Inactive(anon)': string;
    'Active(file)': string;
    'Inactive(file)': string;
    SwapTotal: string;
    SwapFree: string;
    Dirty: string;
    Writeback: string;
    AnonPages: string;
    Mapped: string;
    Shmem: string;
    PageTables: string;
    AnonHugePages: string;
}
interface ProcDiskstats {
    [key: string]: string;
}
interface ProcStat {
    [key: string]: string;
    cpu: string;
    intr: string;
    ctxt: string;
    btime: string;
    processes: string;
    procs_running: string;
    procs_blocked: string;
    softirq: string;
}

/** Get the first element */
type TupleHead<T extends unknown[]> = T[0];
/** Remove the first element */
type TupleTail<T extends unknown[]> = T extends [] ? [] : T extends [unknown] ? [] : T extends [unknown, ...infer U] ? U : unknown[];
type TupleShift<T extends unknown[]> = TupleTail<T>;
/** Get the last element */
type TupleLast<T extends any[]> = T[TupleTail<T>['length']];
/** Remove the last element */
type TupleRemoveLast<T extends any[]> = TypeAssert<Overwrite<TupleTail<T>, T>, any[]>;
/** Insert element at first */
type TupleUnshift<T extends unknown[], X> = [X, ...T];
/** Append element at last */
type TuplePush<T extends any[], X> = [...T, X];
/** Concat two tuples */
type TupleConcat<A extends unknown[], B extends unknown[]> = [...A, ...B];
type TypeAssert<T, A> = T extends A ? T : never;
type Overwrite<T, S> = {
    [P in keyof T]: S[P];
};
/**
 * Whether literal type is in Tuple contains literal,
 *
 * @example ```ts
 * type Foo = isInType<['ab', 'cd'], 'ab'>
 * ```
 * @returns boolean
 */
type isInLiteralTuple<T extends (string | number | symbol)[], K extends string | number | symbol> = [Extract<T[number], K>] extends [never] ? false : true;
type TupleToUnion<T extends unknown[]> = T[number];
type Reverse<Tuple extends any[]> = Reverse_<Tuple, []>;
type Reverse_<Tuple extends any[], Result extends any[]> = {
    1: Result;
    0: Reverse_<TupleTail<Tuple>, TupleUnshift<Result, TupleHead<Tuple>>>;
}[Tuple extends [] ? 1 : 0];

type TrimStart<T extends string, K extends string = ' '> = T extends `${K}${infer Rest}` ? TrimStart<Rest, K> : T;
type TrimEnd<T extends string, K extends string = ' '> = T extends `${infer Rest}${K}` ? TrimEnd<Rest, K> : T;
type Trim<T extends string, K extends string = ' '> = TrimStart<TrimEnd<T, K>, K>;

type MiddlewareConfig<T = unknown> = {
    /**
     * Enable middleware.
     * @default true
     */
    enableMiddleware: boolean;
    options?: T;
} & PathPattern;
type PathPattern = XOR<PathMatchPattern, PathIgnorePattern>;
interface PathMatchPattern {
    /**
     * match and ignore are exclusive exists
     * @description
     *   - `/` match root only
     *   - `/^\/$/` match root only
     */
    match?: MiddlewarePathPattern;
}
interface PathIgnorePattern {
    /**
     * match and ignore are exclusive exists
     * @description
     *   - `/` match root only
     *   - `/^\/$/` match root only
     */
    ignore?: MiddlewarePathPattern;
}
type PathPatternFunc = (url: string) => boolean;
type MiddlewarePathPattern = (string | RegExp | PathPatternFunc)[];

export { AllValues, BigIntStr, CamelKeys, CamelToSnake, CaseConvertTable, CaseType, DateISOString, DbScopedColsByKey, DbScopedColsByTableType, Decimal, Equals, EqualsExt, FormatIntersect, Func, ISO8601String, Invert, JoinTable, JoinTableWithCaseConvert, JsonObject, JsonResp, JsonType, KeyFromValue, KnownKeys, LiteralObject, MiddlewareConfig, MiddlewarePathPattern, NpmPkg, NpmPkgPersion, NpmPkgPublishConfig, NpmPkgRepository, NpmPkgStringObj, Overwrite, OverwriteAnyToUnknown, OverwriteNeverToUnknown, PascalKeys, PathIgnorePattern, PathMatchPattern, PathPattern, PathPatternFunc, PlainJsonValue, ProcCpuinfo, ProcDiskstats, ProcInfo, ProcMeminfo, ProcStat, RecordCamelKeys, RecordPascalKeys, RecordSnakeKeys, RecursiveCamelKeys, RecursivePascalKeys, RecursiveSnakeKeys, Reverse, SnakeKeys, SnakeToCamel, SnakeToPascal, SplitScopedColumn, Spread, StrKey, StrSplit, ToTuple, Trim, TrimEnd, TrimStart, TupleConcat, TupleHead, TupleJoin, TupleLast, TuplePush, TupleRemoveLast, TupleShift, TupleTail, TupleToUnion, TupleUnshift, TypeAssert, UnionToIntersection, UnwrapArrayMember, ValuesOf, Without, XOR, dummyForCI, isInLiteralTuple };
